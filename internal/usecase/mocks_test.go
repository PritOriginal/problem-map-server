// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package usecase

import (
	"context"
	"io"

	"github.com/PritOriginal/problem-map-server/internal/models"
	mock "github.com/stretchr/testify/mock"
)

// NewMockChecksRepository creates a new instance of MockChecksRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockChecksRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockChecksRepository {
	mock := &MockChecksRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockChecksRepository is an autogenerated mock type for the ChecksRepository type
type MockChecksRepository struct {
	mock.Mock
}

type MockChecksRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockChecksRepository) EXPECT() *MockChecksRepository_Expecter {
	return &MockChecksRepository_Expecter{mock: &_m.Mock}
}

// AddCheck provides a mock function for the type MockChecksRepository
func (_mock *MockChecksRepository) AddCheck(ctx context.Context, check models.Check) (int64, error) {
	ret := _mock.Called(ctx, check)

	if len(ret) == 0 {
		panic("no return value specified for AddCheck")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.Check) (int64, error)); ok {
		return returnFunc(ctx, check)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.Check) int64); ok {
		r0 = returnFunc(ctx, check)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, models.Check) error); ok {
		r1 = returnFunc(ctx, check)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockChecksRepository_AddCheck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCheck'
type MockChecksRepository_AddCheck_Call struct {
	*mock.Call
}

// AddCheck is a helper method to define mock.On call
//   - ctx context.Context
//   - check models.Check
func (_e *MockChecksRepository_Expecter) AddCheck(ctx interface{}, check interface{}) *MockChecksRepository_AddCheck_Call {
	return &MockChecksRepository_AddCheck_Call{Call: _e.mock.On("AddCheck", ctx, check)}
}

func (_c *MockChecksRepository_AddCheck_Call) Run(run func(ctx context.Context, check models.Check)) *MockChecksRepository_AddCheck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 models.Check
		if args[1] != nil {
			arg1 = args[1].(models.Check)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChecksRepository_AddCheck_Call) Return(n int64, err error) *MockChecksRepository_AddCheck_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockChecksRepository_AddCheck_Call) RunAndReturn(run func(ctx context.Context, check models.Check) (int64, error)) *MockChecksRepository_AddCheck_Call {
	_c.Call.Return(run)
	return _c
}

// GetCheckById provides a mock function for the type MockChecksRepository
func (_mock *MockChecksRepository) GetCheckById(ctx context.Context, id int) (models.Check, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetCheckById")
	}

	var r0 models.Check
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) (models.Check, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) models.Check); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(models.Check)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockChecksRepository_GetCheckById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCheckById'
type MockChecksRepository_GetCheckById_Call struct {
	*mock.Call
}

// GetCheckById is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockChecksRepository_Expecter) GetCheckById(ctx interface{}, id interface{}) *MockChecksRepository_GetCheckById_Call {
	return &MockChecksRepository_GetCheckById_Call{Call: _e.mock.On("GetCheckById", ctx, id)}
}

func (_c *MockChecksRepository_GetCheckById_Call) Run(run func(ctx context.Context, id int)) *MockChecksRepository_GetCheckById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChecksRepository_GetCheckById_Call) Return(check models.Check, err error) *MockChecksRepository_GetCheckById_Call {
	_c.Call.Return(check, err)
	return _c
}

func (_c *MockChecksRepository_GetCheckById_Call) RunAndReturn(run func(ctx context.Context, id int) (models.Check, error)) *MockChecksRepository_GetCheckById_Call {
	_c.Call.Return(run)
	return _c
}

// GetChecksByMarkId provides a mock function for the type MockChecksRepository
func (_mock *MockChecksRepository) GetChecksByMarkId(ctx context.Context, markId int) ([]models.Check, error) {
	ret := _mock.Called(ctx, markId)

	if len(ret) == 0 {
		panic("no return value specified for GetChecksByMarkId")
	}

	var r0 []models.Check
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) ([]models.Check, error)); ok {
		return returnFunc(ctx, markId)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) []models.Check); ok {
		r0 = returnFunc(ctx, markId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Check)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, markId)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockChecksRepository_GetChecksByMarkId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetChecksByMarkId'
type MockChecksRepository_GetChecksByMarkId_Call struct {
	*mock.Call
}

// GetChecksByMarkId is a helper method to define mock.On call
//   - ctx context.Context
//   - markId int
func (_e *MockChecksRepository_Expecter) GetChecksByMarkId(ctx interface{}, markId interface{}) *MockChecksRepository_GetChecksByMarkId_Call {
	return &MockChecksRepository_GetChecksByMarkId_Call{Call: _e.mock.On("GetChecksByMarkId", ctx, markId)}
}

func (_c *MockChecksRepository_GetChecksByMarkId_Call) Run(run func(ctx context.Context, markId int)) *MockChecksRepository_GetChecksByMarkId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChecksRepository_GetChecksByMarkId_Call) Return(checks []models.Check, err error) *MockChecksRepository_GetChecksByMarkId_Call {
	_c.Call.Return(checks, err)
	return _c
}

func (_c *MockChecksRepository_GetChecksByMarkId_Call) RunAndReturn(run func(ctx context.Context, markId int) ([]models.Check, error)) *MockChecksRepository_GetChecksByMarkId_Call {
	_c.Call.Return(run)
	return _c
}

// GetChecksByUserId provides a mock function for the type MockChecksRepository
func (_mock *MockChecksRepository) GetChecksByUserId(ctx context.Context, userId int) ([]models.Check, error) {
	ret := _mock.Called(ctx, userId)

	if len(ret) == 0 {
		panic("no return value specified for GetChecksByUserId")
	}

	var r0 []models.Check
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) ([]models.Check, error)); ok {
		return returnFunc(ctx, userId)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) []models.Check); ok {
		r0 = returnFunc(ctx, userId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Check)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, userId)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockChecksRepository_GetChecksByUserId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetChecksByUserId'
type MockChecksRepository_GetChecksByUserId_Call struct {
	*mock.Call
}

// GetChecksByUserId is a helper method to define mock.On call
//   - ctx context.Context
//   - userId int
func (_e *MockChecksRepository_Expecter) GetChecksByUserId(ctx interface{}, userId interface{}) *MockChecksRepository_GetChecksByUserId_Call {
	return &MockChecksRepository_GetChecksByUserId_Call{Call: _e.mock.On("GetChecksByUserId", ctx, userId)}
}

func (_c *MockChecksRepository_GetChecksByUserId_Call) Run(run func(ctx context.Context, userId int)) *MockChecksRepository_GetChecksByUserId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChecksRepository_GetChecksByUserId_Call) Return(checks []models.Check, err error) *MockChecksRepository_GetChecksByUserId_Call {
	_c.Call.Return(checks, err)
	return _c
}

func (_c *MockChecksRepository_GetChecksByUserId_Call) RunAndReturn(run func(ctx context.Context, userId int) ([]models.Check, error)) *MockChecksRepository_GetChecksByUserId_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMapRepository creates a new instance of MockMapRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMapRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMapRepository {
	mock := &MockMapRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMapRepository is an autogenerated mock type for the MapRepository type
type MockMapRepository struct {
	mock.Mock
}

type MockMapRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMapRepository) EXPECT() *MockMapRepository_Expecter {
	return &MockMapRepository_Expecter{mock: &_m.Mock}
}

// GetCities provides a mock function for the type MockMapRepository
func (_mock *MockMapRepository) GetCities(ctx context.Context) ([]models.City, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetCities")
	}

	var r0 []models.City
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.City, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.City); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.City)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMapRepository_GetCities_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCities'
type MockMapRepository_GetCities_Call struct {
	*mock.Call
}

// GetCities is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockMapRepository_Expecter) GetCities(ctx interface{}) *MockMapRepository_GetCities_Call {
	return &MockMapRepository_GetCities_Call{Call: _e.mock.On("GetCities", ctx)}
}

func (_c *MockMapRepository_GetCities_Call) Run(run func(ctx context.Context)) *MockMapRepository_GetCities_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMapRepository_GetCities_Call) Return(citys []models.City, err error) *MockMapRepository_GetCities_Call {
	_c.Call.Return(citys, err)
	return _c
}

func (_c *MockMapRepository_GetCities_Call) RunAndReturn(run func(ctx context.Context) ([]models.City, error)) *MockMapRepository_GetCities_Call {
	_c.Call.Return(run)
	return _c
}

// GetDistricts provides a mock function for the type MockMapRepository
func (_mock *MockMapRepository) GetDistricts(ctx context.Context) ([]models.District, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetDistricts")
	}

	var r0 []models.District
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.District, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.District); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.District)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMapRepository_GetDistricts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDistricts'
type MockMapRepository_GetDistricts_Call struct {
	*mock.Call
}

// GetDistricts is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockMapRepository_Expecter) GetDistricts(ctx interface{}) *MockMapRepository_GetDistricts_Call {
	return &MockMapRepository_GetDistricts_Call{Call: _e.mock.On("GetDistricts", ctx)}
}

func (_c *MockMapRepository_GetDistricts_Call) Run(run func(ctx context.Context)) *MockMapRepository_GetDistricts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMapRepository_GetDistricts_Call) Return(districts []models.District, err error) *MockMapRepository_GetDistricts_Call {
	_c.Call.Return(districts, err)
	return _c
}

func (_c *MockMapRepository_GetDistricts_Call) RunAndReturn(run func(ctx context.Context) ([]models.District, error)) *MockMapRepository_GetDistricts_Call {
	_c.Call.Return(run)
	return _c
}

// GetRegions provides a mock function for the type MockMapRepository
func (_mock *MockMapRepository) GetRegions(ctx context.Context) ([]models.Region, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetRegions")
	}

	var r0 []models.Region
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.Region, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.Region); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Region)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMapRepository_GetRegions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRegions'
type MockMapRepository_GetRegions_Call struct {
	*mock.Call
}

// GetRegions is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockMapRepository_Expecter) GetRegions(ctx interface{}) *MockMapRepository_GetRegions_Call {
	return &MockMapRepository_GetRegions_Call{Call: _e.mock.On("GetRegions", ctx)}
}

func (_c *MockMapRepository_GetRegions_Call) Run(run func(ctx context.Context)) *MockMapRepository_GetRegions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMapRepository_GetRegions_Call) Return(regions []models.Region, err error) *MockMapRepository_GetRegions_Call {
	_c.Call.Return(regions, err)
	return _c
}

func (_c *MockMapRepository_GetRegions_Call) RunAndReturn(run func(ctx context.Context) ([]models.Region, error)) *MockMapRepository_GetRegions_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMarksRepository creates a new instance of MockMarksRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMarksRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMarksRepository {
	mock := &MockMarksRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMarksRepository is an autogenerated mock type for the MarksRepository type
type MockMarksRepository struct {
	mock.Mock
}

type MockMarksRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMarksRepository) EXPECT() *MockMarksRepository_Expecter {
	return &MockMarksRepository_Expecter{mock: &_m.Mock}
}

// AddMark provides a mock function for the type MockMarksRepository
func (_mock *MockMarksRepository) AddMark(ctx context.Context, mark models.Mark) (int64, error) {
	ret := _mock.Called(ctx, mark)

	if len(ret) == 0 {
		panic("no return value specified for AddMark")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.Mark) (int64, error)); ok {
		return returnFunc(ctx, mark)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.Mark) int64); ok {
		r0 = returnFunc(ctx, mark)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, models.Mark) error); ok {
		r1 = returnFunc(ctx, mark)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMarksRepository_AddMark_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddMark'
type MockMarksRepository_AddMark_Call struct {
	*mock.Call
}

// AddMark is a helper method to define mock.On call
//   - ctx context.Context
//   - mark models.Mark
func (_e *MockMarksRepository_Expecter) AddMark(ctx interface{}, mark interface{}) *MockMarksRepository_AddMark_Call {
	return &MockMarksRepository_AddMark_Call{Call: _e.mock.On("AddMark", ctx, mark)}
}

func (_c *MockMarksRepository_AddMark_Call) Run(run func(ctx context.Context, mark models.Mark)) *MockMarksRepository_AddMark_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 models.Mark
		if args[1] != nil {
			arg1 = args[1].(models.Mark)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMarksRepository_AddMark_Call) Return(n int64, err error) *MockMarksRepository_AddMark_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockMarksRepository_AddMark_Call) RunAndReturn(run func(ctx context.Context, mark models.Mark) (int64, error)) *MockMarksRepository_AddMark_Call {
	_c.Call.Return(run)
	return _c
}

// GetMarkById provides a mock function for the type MockMarksRepository
func (_mock *MockMarksRepository) GetMarkById(ctx context.Context, id int) (models.Mark, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetMarkById")
	}

	var r0 models.Mark
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) (models.Mark, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) models.Mark); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(models.Mark)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMarksRepository_GetMarkById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMarkById'
type MockMarksRepository_GetMarkById_Call struct {
	*mock.Call
}

// GetMarkById is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockMarksRepository_Expecter) GetMarkById(ctx interface{}, id interface{}) *MockMarksRepository_GetMarkById_Call {
	return &MockMarksRepository_GetMarkById_Call{Call: _e.mock.On("GetMarkById", ctx, id)}
}

func (_c *MockMarksRepository_GetMarkById_Call) Run(run func(ctx context.Context, id int)) *MockMarksRepository_GetMarkById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMarksRepository_GetMarkById_Call) Return(mark models.Mark, err error) *MockMarksRepository_GetMarkById_Call {
	_c.Call.Return(mark, err)
	return _c
}

func (_c *MockMarksRepository_GetMarkById_Call) RunAndReturn(run func(ctx context.Context, id int) (models.Mark, error)) *MockMarksRepository_GetMarkById_Call {
	_c.Call.Return(run)
	return _c
}

// GetMarkStatuses provides a mock function for the type MockMarksRepository
func (_mock *MockMarksRepository) GetMarkStatuses(ctx context.Context) ([]models.MarkStatus, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetMarkStatuses")
	}

	var r0 []models.MarkStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.MarkStatus, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.MarkStatus); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.MarkStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMarksRepository_GetMarkStatuses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMarkStatuses'
type MockMarksRepository_GetMarkStatuses_Call struct {
	*mock.Call
}

// GetMarkStatuses is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockMarksRepository_Expecter) GetMarkStatuses(ctx interface{}) *MockMarksRepository_GetMarkStatuses_Call {
	return &MockMarksRepository_GetMarkStatuses_Call{Call: _e.mock.On("GetMarkStatuses", ctx)}
}

func (_c *MockMarksRepository_GetMarkStatuses_Call) Run(run func(ctx context.Context)) *MockMarksRepository_GetMarkStatuses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMarksRepository_GetMarkStatuses_Call) Return(markStatuss []models.MarkStatus, err error) *MockMarksRepository_GetMarkStatuses_Call {
	_c.Call.Return(markStatuss, err)
	return _c
}

func (_c *MockMarksRepository_GetMarkStatuses_Call) RunAndReturn(run func(ctx context.Context) ([]models.MarkStatus, error)) *MockMarksRepository_GetMarkStatuses_Call {
	_c.Call.Return(run)
	return _c
}

// GetMarkTypes provides a mock function for the type MockMarksRepository
func (_mock *MockMarksRepository) GetMarkTypes(ctx context.Context) ([]models.MarkType, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetMarkTypes")
	}

	var r0 []models.MarkType
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.MarkType, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.MarkType); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.MarkType)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMarksRepository_GetMarkTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMarkTypes'
type MockMarksRepository_GetMarkTypes_Call struct {
	*mock.Call
}

// GetMarkTypes is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockMarksRepository_Expecter) GetMarkTypes(ctx interface{}) *MockMarksRepository_GetMarkTypes_Call {
	return &MockMarksRepository_GetMarkTypes_Call{Call: _e.mock.On("GetMarkTypes", ctx)}
}

func (_c *MockMarksRepository_GetMarkTypes_Call) Run(run func(ctx context.Context)) *MockMarksRepository_GetMarkTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMarksRepository_GetMarkTypes_Call) Return(markTypes []models.MarkType, err error) *MockMarksRepository_GetMarkTypes_Call {
	_c.Call.Return(markTypes, err)
	return _c
}

func (_c *MockMarksRepository_GetMarkTypes_Call) RunAndReturn(run func(ctx context.Context) ([]models.MarkType, error)) *MockMarksRepository_GetMarkTypes_Call {
	_c.Call.Return(run)
	return _c
}

// GetMarks provides a mock function for the type MockMarksRepository
func (_mock *MockMarksRepository) GetMarks(ctx context.Context) ([]models.Mark, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetMarks")
	}

	var r0 []models.Mark
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.Mark, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.Mark); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Mark)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMarksRepository_GetMarks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMarks'
type MockMarksRepository_GetMarks_Call struct {
	*mock.Call
}

// GetMarks is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockMarksRepository_Expecter) GetMarks(ctx interface{}) *MockMarksRepository_GetMarks_Call {
	return &MockMarksRepository_GetMarks_Call{Call: _e.mock.On("GetMarks", ctx)}
}

func (_c *MockMarksRepository_GetMarks_Call) Run(run func(ctx context.Context)) *MockMarksRepository_GetMarks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockMarksRepository_GetMarks_Call) Return(marks []models.Mark, err error) *MockMarksRepository_GetMarks_Call {
	_c.Call.Return(marks, err)
	return _c
}

func (_c *MockMarksRepository_GetMarks_Call) RunAndReturn(run func(ctx context.Context) ([]models.Mark, error)) *MockMarksRepository_GetMarks_Call {
	_c.Call.Return(run)
	return _c
}

// GetMarksByUserId provides a mock function for the type MockMarksRepository
func (_mock *MockMarksRepository) GetMarksByUserId(ctx context.Context, userId int) ([]models.Mark, error) {
	ret := _mock.Called(ctx, userId)

	if len(ret) == 0 {
		panic("no return value specified for GetMarksByUserId")
	}

	var r0 []models.Mark
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) ([]models.Mark, error)); ok {
		return returnFunc(ctx, userId)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) []models.Mark); ok {
		r0 = returnFunc(ctx, userId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Mark)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, userId)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMarksRepository_GetMarksByUserId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMarksByUserId'
type MockMarksRepository_GetMarksByUserId_Call struct {
	*mock.Call
}

// GetMarksByUserId is a helper method to define mock.On call
//   - ctx context.Context
//   - userId int
func (_e *MockMarksRepository_Expecter) GetMarksByUserId(ctx interface{}, userId interface{}) *MockMarksRepository_GetMarksByUserId_Call {
	return &MockMarksRepository_GetMarksByUserId_Call{Call: _e.mock.On("GetMarksByUserId", ctx, userId)}
}

func (_c *MockMarksRepository_GetMarksByUserId_Call) Run(run func(ctx context.Context, userId int)) *MockMarksRepository_GetMarksByUserId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMarksRepository_GetMarksByUserId_Call) Return(marks []models.Mark, err error) *MockMarksRepository_GetMarksByUserId_Call {
	_c.Call.Return(marks, err)
	return _c
}

func (_c *MockMarksRepository_GetMarksByUserId_Call) RunAndReturn(run func(ctx context.Context, userId int) ([]models.Mark, error)) *MockMarksRepository_GetMarksByUserId_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMarkStatus provides a mock function for the type MockMarksRepository
func (_mock *MockMarksRepository) UpdateMarkStatus(ctx context.Context, markId int, markStatusId models.MarkStatusType) error {
	ret := _mock.Called(ctx, markId, markStatusId)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMarkStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, models.MarkStatusType) error); ok {
		r0 = returnFunc(ctx, markId, markStatusId)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMarksRepository_UpdateMarkStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMarkStatus'
type MockMarksRepository_UpdateMarkStatus_Call struct {
	*mock.Call
}

// UpdateMarkStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - markId int
//   - markStatusId models.MarkStatusType
func (_e *MockMarksRepository_Expecter) UpdateMarkStatus(ctx interface{}, markId interface{}, markStatusId interface{}) *MockMarksRepository_UpdateMarkStatus_Call {
	return &MockMarksRepository_UpdateMarkStatus_Call{Call: _e.mock.On("UpdateMarkStatus", ctx, markId, markStatusId)}
}

func (_c *MockMarksRepository_UpdateMarkStatus_Call) Run(run func(ctx context.Context, markId int, markStatusId models.MarkStatusType)) *MockMarksRepository_UpdateMarkStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 models.MarkStatusType
		if args[2] != nil {
			arg2 = args[2].(models.MarkStatusType)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockMarksRepository_UpdateMarkStatus_Call) Return(err error) *MockMarksRepository_UpdateMarkStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMarksRepository_UpdateMarkStatus_Call) RunAndReturn(run func(ctx context.Context, markId int, markStatusId models.MarkStatusType) error) *MockMarksRepository_UpdateMarkStatus_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPhotosRepository creates a new instance of MockPhotosRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPhotosRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPhotosRepository {
	mock := &MockPhotosRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPhotosRepository is an autogenerated mock type for the PhotosRepository type
type MockPhotosRepository struct {
	mock.Mock
}

type MockPhotosRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPhotosRepository) EXPECT() *MockPhotosRepository_Expecter {
	return &MockPhotosRepository_Expecter{mock: &_m.Mock}
}

// AddPhotos provides a mock function for the type MockPhotosRepository
func (_mock *MockPhotosRepository) AddPhotos(ctx context.Context, markId int, checkId int, photos []io.Reader) error {
	ret := _mock.Called(ctx, markId, checkId, photos)

	if len(ret) == 0 {
		panic("no return value specified for AddPhotos")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int, []io.Reader) error); ok {
		r0 = returnFunc(ctx, markId, checkId, photos)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockPhotosRepository_AddPhotos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddPhotos'
type MockPhotosRepository_AddPhotos_Call struct {
	*mock.Call
}

// AddPhotos is a helper method to define mock.On call
//   - ctx context.Context
//   - markId int
//   - checkId int
//   - photos []io.Reader
func (_e *MockPhotosRepository_Expecter) AddPhotos(ctx interface{}, markId interface{}, checkId interface{}, photos interface{}) *MockPhotosRepository_AddPhotos_Call {
	return &MockPhotosRepository_AddPhotos_Call{Call: _e.mock.On("AddPhotos", ctx, markId, checkId, photos)}
}

func (_c *MockPhotosRepository_AddPhotos_Call) Run(run func(ctx context.Context, markId int, checkId int, photos []io.Reader)) *MockPhotosRepository_AddPhotos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 []io.Reader
		if args[3] != nil {
			arg3 = args[3].([]io.Reader)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockPhotosRepository_AddPhotos_Call) Return(err error) *MockPhotosRepository_AddPhotos_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockPhotosRepository_AddPhotos_Call) RunAndReturn(run func(ctx context.Context, markId int, checkId int, photos []io.Reader) error) *MockPhotosRepository_AddPhotos_Call {
	_c.Call.Return(run)
	return _c
}

// GetPhotos provides a mock function for the type MockPhotosRepository
func (_mock *MockPhotosRepository) GetPhotos(ctx context.Context) (map[int]map[int][]string, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetPhotos")
	}

	var r0 map[int]map[int][]string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (map[int]map[int][]string, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) map[int]map[int][]string); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[int]map[int][]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPhotosRepository_GetPhotos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPhotos'
type MockPhotosRepository_GetPhotos_Call struct {
	*mock.Call
}

// GetPhotos is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPhotosRepository_Expecter) GetPhotos(ctx interface{}) *MockPhotosRepository_GetPhotos_Call {
	return &MockPhotosRepository_GetPhotos_Call{Call: _e.mock.On("GetPhotos", ctx)}
}

func (_c *MockPhotosRepository_GetPhotos_Call) Run(run func(ctx context.Context)) *MockPhotosRepository_GetPhotos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockPhotosRepository_GetPhotos_Call) Return(intToIntToStrings map[int]map[int][]string, err error) *MockPhotosRepository_GetPhotos_Call {
	_c.Call.Return(intToIntToStrings, err)
	return _c
}

func (_c *MockPhotosRepository_GetPhotos_Call) RunAndReturn(run func(ctx context.Context) (map[int]map[int][]string, error)) *MockPhotosRepository_GetPhotos_Call {
	_c.Call.Return(run)
	return _c
}

// GetPhotosByCheckId provides a mock function for the type MockPhotosRepository
func (_mock *MockPhotosRepository) GetPhotosByCheckId(ctx context.Context, markId int, checkId int) ([]string, error) {
	ret := _mock.Called(ctx, markId, checkId)

	if len(ret) == 0 {
		panic("no return value specified for GetPhotosByCheckId")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) ([]string, error)); ok {
		return returnFunc(ctx, markId, checkId)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) []string); ok {
		r0 = returnFunc(ctx, markId, checkId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, int) error); ok {
		r1 = returnFunc(ctx, markId, checkId)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPhotosRepository_GetPhotosByCheckId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPhotosByCheckId'
type MockPhotosRepository_GetPhotosByCheckId_Call struct {
	*mock.Call
}

// GetPhotosByCheckId is a helper method to define mock.On call
//   - ctx context.Context
//   - markId int
//   - checkId int
func (_e *MockPhotosRepository_Expecter) GetPhotosByCheckId(ctx interface{}, markId interface{}, checkId interface{}) *MockPhotosRepository_GetPhotosByCheckId_Call {
	return &MockPhotosRepository_GetPhotosByCheckId_Call{Call: _e.mock.On("GetPhotosByCheckId", ctx, markId, checkId)}
}

func (_c *MockPhotosRepository_GetPhotosByCheckId_Call) Run(run func(ctx context.Context, markId int, checkId int)) *MockPhotosRepository_GetPhotosByCheckId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockPhotosRepository_GetPhotosByCheckId_Call) Return(strings []string, err error) *MockPhotosRepository_GetPhotosByCheckId_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *MockPhotosRepository_GetPhotosByCheckId_Call) RunAndReturn(run func(ctx context.Context, markId int, checkId int) ([]string, error)) *MockPhotosRepository_GetPhotosByCheckId_Call {
	_c.Call.Return(run)
	return _c
}

// GetPhotosByMarkId provides a mock function for the type MockPhotosRepository
func (_mock *MockPhotosRepository) GetPhotosByMarkId(ctx context.Context, markId int) (map[int]map[int][]string, error) {
	ret := _mock.Called(ctx, markId)

	if len(ret) == 0 {
		panic("no return value specified for GetPhotosByMarkId")
	}

	var r0 map[int]map[int][]string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) (map[int]map[int][]string, error)); ok {
		return returnFunc(ctx, markId)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) map[int]map[int][]string); ok {
		r0 = returnFunc(ctx, markId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[int]map[int][]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, markId)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPhotosRepository_GetPhotosByMarkId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPhotosByMarkId'
type MockPhotosRepository_GetPhotosByMarkId_Call struct {
	*mock.Call
}

// GetPhotosByMarkId is a helper method to define mock.On call
//   - ctx context.Context
//   - markId int
func (_e *MockPhotosRepository_Expecter) GetPhotosByMarkId(ctx interface{}, markId interface{}) *MockPhotosRepository_GetPhotosByMarkId_Call {
	return &MockPhotosRepository_GetPhotosByMarkId_Call{Call: _e.mock.On("GetPhotosByMarkId", ctx, markId)}
}

func (_c *MockPhotosRepository_GetPhotosByMarkId_Call) Run(run func(ctx context.Context, markId int)) *MockPhotosRepository_GetPhotosByMarkId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockPhotosRepository_GetPhotosByMarkId_Call) Return(intToIntToStrings map[int]map[int][]string, err error) *MockPhotosRepository_GetPhotosByMarkId_Call {
	_c.Call.Return(intToIntToStrings, err)
	return _c
}

func (_c *MockPhotosRepository_GetPhotosByMarkId_Call) RunAndReturn(run func(ctx context.Context, markId int) (map[int]map[int][]string, error)) *MockPhotosRepository_GetPhotosByMarkId_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTasksRepository creates a new instance of MockTasksRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTasksRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTasksRepository {
	mock := &MockTasksRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTasksRepository is an autogenerated mock type for the TasksRepository type
type MockTasksRepository struct {
	mock.Mock
}

type MockTasksRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTasksRepository) EXPECT() *MockTasksRepository_Expecter {
	return &MockTasksRepository_Expecter{mock: &_m.Mock}
}

// AddTask provides a mock function for the type MockTasksRepository
func (_mock *MockTasksRepository) AddTask(ctx context.Context, task models.Task) (int64, error) {
	ret := _mock.Called(ctx, task)

	if len(ret) == 0 {
		panic("no return value specified for AddTask")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.Task) (int64, error)); ok {
		return returnFunc(ctx, task)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.Task) int64); ok {
		r0 = returnFunc(ctx, task)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, models.Task) error); ok {
		r1 = returnFunc(ctx, task)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTasksRepository_AddTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddTask'
type MockTasksRepository_AddTask_Call struct {
	*mock.Call
}

// AddTask is a helper method to define mock.On call
//   - ctx context.Context
//   - task models.Task
func (_e *MockTasksRepository_Expecter) AddTask(ctx interface{}, task interface{}) *MockTasksRepository_AddTask_Call {
	return &MockTasksRepository_AddTask_Call{Call: _e.mock.On("AddTask", ctx, task)}
}

func (_c *MockTasksRepository_AddTask_Call) Run(run func(ctx context.Context, task models.Task)) *MockTasksRepository_AddTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 models.Task
		if args[1] != nil {
			arg1 = args[1].(models.Task)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTasksRepository_AddTask_Call) Return(n int64, err error) *MockTasksRepository_AddTask_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockTasksRepository_AddTask_Call) RunAndReturn(run func(ctx context.Context, task models.Task) (int64, error)) *MockTasksRepository_AddTask_Call {
	_c.Call.Return(run)
	return _c
}

// GetTaskById provides a mock function for the type MockTasksRepository
func (_mock *MockTasksRepository) GetTaskById(ctx context.Context, id int) (models.Task, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetTaskById")
	}

	var r0 models.Task
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) (models.Task, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) models.Task); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(models.Task)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTasksRepository_GetTaskById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTaskById'
type MockTasksRepository_GetTaskById_Call struct {
	*mock.Call
}

// GetTaskById is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockTasksRepository_Expecter) GetTaskById(ctx interface{}, id interface{}) *MockTasksRepository_GetTaskById_Call {
	return &MockTasksRepository_GetTaskById_Call{Call: _e.mock.On("GetTaskById", ctx, id)}
}

func (_c *MockTasksRepository_GetTaskById_Call) Run(run func(ctx context.Context, id int)) *MockTasksRepository_GetTaskById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTasksRepository_GetTaskById_Call) Return(task models.Task, err error) *MockTasksRepository_GetTaskById_Call {
	_c.Call.Return(task, err)
	return _c
}

func (_c *MockTasksRepository_GetTaskById_Call) RunAndReturn(run func(ctx context.Context, id int) (models.Task, error)) *MockTasksRepository_GetTaskById_Call {
	_c.Call.Return(run)
	return _c
}

// GetTasks provides a mock function for the type MockTasksRepository
func (_mock *MockTasksRepository) GetTasks(ctx context.Context) ([]models.Task, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetTasks")
	}

	var r0 []models.Task
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.Task, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.Task); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Task)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTasksRepository_GetTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTasks'
type MockTasksRepository_GetTasks_Call struct {
	*mock.Call
}

// GetTasks is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockTasksRepository_Expecter) GetTasks(ctx interface{}) *MockTasksRepository_GetTasks_Call {
	return &MockTasksRepository_GetTasks_Call{Call: _e.mock.On("GetTasks", ctx)}
}

func (_c *MockTasksRepository_GetTasks_Call) Run(run func(ctx context.Context)) *MockTasksRepository_GetTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockTasksRepository_GetTasks_Call) Return(tasks []models.Task, err error) *MockTasksRepository_GetTasks_Call {
	_c.Call.Return(tasks, err)
	return _c
}

func (_c *MockTasksRepository_GetTasks_Call) RunAndReturn(run func(ctx context.Context) ([]models.Task, error)) *MockTasksRepository_GetTasks_Call {
	_c.Call.Return(run)
	return _c
}

// GetTasksByUserId provides a mock function for the type MockTasksRepository
func (_mock *MockTasksRepository) GetTasksByUserId(ctx context.Context, userId int) ([]models.Task, error) {
	ret := _mock.Called(ctx, userId)

	if len(ret) == 0 {
		panic("no return value specified for GetTasksByUserId")
	}

	var r0 []models.Task
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) ([]models.Task, error)); ok {
		return returnFunc(ctx, userId)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) []models.Task); ok {
		r0 = returnFunc(ctx, userId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Task)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, userId)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTasksRepository_GetTasksByUserId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTasksByUserId'
type MockTasksRepository_GetTasksByUserId_Call struct {
	*mock.Call
}

// GetTasksByUserId is a helper method to define mock.On call
//   - ctx context.Context
//   - userId int
func (_e *MockTasksRepository_Expecter) GetTasksByUserId(ctx interface{}, userId interface{}) *MockTasksRepository_GetTasksByUserId_Call {
	return &MockTasksRepository_GetTasksByUserId_Call{Call: _e.mock.On("GetTasksByUserId", ctx, userId)}
}

func (_c *MockTasksRepository_GetTasksByUserId_Call) Run(run func(ctx context.Context, userId int)) *MockTasksRepository_GetTasksByUserId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTasksRepository_GetTasksByUserId_Call) Return(tasks []models.Task, err error) *MockTasksRepository_GetTasksByUserId_Call {
	_c.Call.Return(tasks, err)
	return _c
}

func (_c *MockTasksRepository_GetTasksByUserId_Call) RunAndReturn(run func(ctx context.Context, userId int) ([]models.Task, error)) *MockTasksRepository_GetTasksByUserId_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUsersRepository creates a new instance of MockUsersRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUsersRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUsersRepository {
	mock := &MockUsersRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUsersRepository is an autogenerated mock type for the UsersRepository type
type MockUsersRepository struct {
	mock.Mock
}

type MockUsersRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUsersRepository) EXPECT() *MockUsersRepository_Expecter {
	return &MockUsersRepository_Expecter{mock: &_m.Mock}
}

// AddUser provides a mock function for the type MockUsersRepository
func (_mock *MockUsersRepository) AddUser(ctx context.Context, user models.User) (int64, error) {
	ret := _mock.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for AddUser")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.User) (int64, error)); ok {
		return returnFunc(ctx, user)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, models.User) int64); ok {
		r0 = returnFunc(ctx, user)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, models.User) error); ok {
		r1 = returnFunc(ctx, user)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUsersRepository_AddUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddUser'
type MockUsersRepository_AddUser_Call struct {
	*mock.Call
}

// AddUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user models.User
func (_e *MockUsersRepository_Expecter) AddUser(ctx interface{}, user interface{}) *MockUsersRepository_AddUser_Call {
	return &MockUsersRepository_AddUser_Call{Call: _e.mock.On("AddUser", ctx, user)}
}

func (_c *MockUsersRepository_AddUser_Call) Run(run func(ctx context.Context, user models.User)) *MockUsersRepository_AddUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 models.User
		if args[1] != nil {
			arg1 = args[1].(models.User)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUsersRepository_AddUser_Call) Return(n int64, err error) *MockUsersRepository_AddUser_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockUsersRepository_AddUser_Call) RunAndReturn(run func(ctx context.Context, user models.User) (int64, error)) *MockUsersRepository_AddUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserById provides a mock function for the type MockUsersRepository
func (_mock *MockUsersRepository) GetUserById(ctx context.Context, id int) (models.User, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetUserById")
	}

	var r0 models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) (models.User, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) models.User); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(models.User)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUsersRepository_GetUserById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserById'
type MockUsersRepository_GetUserById_Call struct {
	*mock.Call
}

// GetUserById is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockUsersRepository_Expecter) GetUserById(ctx interface{}, id interface{}) *MockUsersRepository_GetUserById_Call {
	return &MockUsersRepository_GetUserById_Call{Call: _e.mock.On("GetUserById", ctx, id)}
}

func (_c *MockUsersRepository_GetUserById_Call) Run(run func(ctx context.Context, id int)) *MockUsersRepository_GetUserById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUsersRepository_GetUserById_Call) Return(user models.User, err error) *MockUsersRepository_GetUserById_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockUsersRepository_GetUserById_Call) RunAndReturn(run func(ctx context.Context, id int) (models.User, error)) *MockUsersRepository_GetUserById_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByLogin provides a mock function for the type MockUsersRepository
func (_mock *MockUsersRepository) GetUserByLogin(ctx context.Context, username string) (models.User, error) {
	ret := _mock.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByLogin")
	}

	var r0 models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (models.User, error)); ok {
		return returnFunc(ctx, username)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) models.User); ok {
		r0 = returnFunc(ctx, username)
	} else {
		r0 = ret.Get(0).(models.User)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, username)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUsersRepository_GetUserByLogin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByLogin'
type MockUsersRepository_GetUserByLogin_Call struct {
	*mock.Call
}

// GetUserByLogin is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
func (_e *MockUsersRepository_Expecter) GetUserByLogin(ctx interface{}, username interface{}) *MockUsersRepository_GetUserByLogin_Call {
	return &MockUsersRepository_GetUserByLogin_Call{Call: _e.mock.On("GetUserByLogin", ctx, username)}
}

func (_c *MockUsersRepository_GetUserByLogin_Call) Run(run func(ctx context.Context, username string)) *MockUsersRepository_GetUserByLogin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUsersRepository_GetUserByLogin_Call) Return(user models.User, err error) *MockUsersRepository_GetUserByLogin_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockUsersRepository_GetUserByLogin_Call) RunAndReturn(run func(ctx context.Context, username string) (models.User, error)) *MockUsersRepository_GetUserByLogin_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsers provides a mock function for the type MockUsersRepository
func (_mock *MockUsersRepository) GetUsers(ctx context.Context) ([]models.User, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetUsers")
	}

	var r0 []models.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]models.User, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []models.User); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUsersRepository_GetUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsers'
type MockUsersRepository_GetUsers_Call struct {
	*mock.Call
}

// GetUsers is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUsersRepository_Expecter) GetUsers(ctx interface{}) *MockUsersRepository_GetUsers_Call {
	return &MockUsersRepository_GetUsers_Call{Call: _e.mock.On("GetUsers", ctx)}
}

func (_c *MockUsersRepository_GetUsers_Call) Run(run func(ctx context.Context)) *MockUsersRepository_GetUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockUsersRepository_GetUsers_Call) Return(users []models.User, err error) *MockUsersRepository_GetUsers_Call {
	_c.Call.Return(users, err)
	return _c
}

func (_c *MockUsersRepository_GetUsers_Call) RunAndReturn(run func(ctx context.Context) ([]models.User, error)) *MockUsersRepository_GetUsers_Call {
	_c.Call.Return(run)
	return _c
}
